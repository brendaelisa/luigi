<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /> <title>Juego Plataforma Web</title>
    <link rel="icon" href="data:,">

    <style>
        body {
            margin: 0;
            background: #87CEEB; /* azul cielo */
            overflow: hidden; /* Evita barras de scroll si el contenido se desborda */
            user-select: none; /* Evita que se pueda seleccionar texto */
            touch-action: manipulation; /* Optimización para eventos táctiles, previene doble toque para zoom */
            display: flex; /* Para centrar el canvas verticalmente si sobra espacio */
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh; /* Asegura que el body ocupe al menos el alto de la pantalla */
        }
        canvas {
            display: block;
            margin: 0 auto;
            background: #87CEEB;
            border: 2px solid #333;
            max-width: 100vw; /* Asegura que el canvas no sea más ancho que el viewport */
            /* Altura responsiva: usa calc para dejar espacio a los controles */
            height: calc(100vh - 100px); /* Ajusta 100px según el espacio necesario para controles y un poco de margen */
            max-height: 600px; /* Límite superior para la altura del canvas en pantallas grandes */
            width: auto; /* Permite que el ancho se ajuste manteniendo la proporción si la altura es el factor limitante */
            object-fit: contain; /* Asegura que el contenido del canvas se escale correctamente dentro de sus dimensiones CSS */
        }
        #controls {
            position: fixed; /* Mantiene los controles visibles en la parte inferior */
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px; /* Aumentado el espacio entre botones para mejor usabilidad táctil */
            user-select: none;
            z-index: 10; /* Asegura que los controles estén por encima del canvas */
            padding: 10px 0; /* Espacio alrededor de los controles */
        }
        button {
            padding: 15px 25px; /* Aumentado el padding para hacer los botones más grandes */
            font-size: 24px; /* Aumentado el tamaño de la fuente para mejor visibilidad */
            border-radius: 12px; /* Bordes más redondeados */
            border: none;
            background: #444;
            color: white;
            opacity: 0.8; /* Ligeramente más opaco para que destaquen */
            cursor: pointer; /* Indica que es clickeable */
            box-shadow: 0 4px 6px rgba(0,0,0,0.3); /* Sombra para dar profundidad */
            transition: background 0.2s ease, transform 0.1s ease; /* Transiciones suaves */
        }
        button:active {
            background: #222;
            transform: scale(0.95); /* Pequeña escala al presionar */
            box-shadow: 0 2px 3px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body>
    <canvas id="game" width="1000" height="600"></canvas>

    <div id="controls">
        <button id="leftBtn">◀</button>
        <button id="jumpBtn">▲</button>
        <button id="rightBtn">▶</button>
    </div>

<script>
(() => {
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // Variables del juego
    const WIDTH = canvas.width; // Ancho lógico interno del canvas
    const HEIGHT = canvas.height; // Alto lógico interno del canvas

    // Colores
    const COLOR_PLATAFORMA = '#8B4513';
    const COLOR_JUGADOR = '#FF4500'; // naranja fuerte
    const COLOR_MONEDA = '#FFD700';
    const COLOR_ENEMIGO = '#0000CD';
    const COLOR_META = '#228B22'; // verde meta
    const COLOR_FONDO = '#87CEEB';

    // Física
    const GRAVEDAD = 0.7;
    const FRICTION = 0.8;
    const MAX_VEL_X = 7;
    const SALTO_FUERZA = -15;

    // Estado del jugador
    let jugador = {
        x: 50,
        y: HEIGHT - 70,
        radio: 20,
        velX: 0,
        velY: 0,
        enSuelo: false,
        saltosRestantes: 2, // Para el doble salto
        vidas: 3,
        puntos: 0
    };

    // Cámara (para scroll horizontal)
    let camaraX = 0;

    // Teclas/Controles
    let teclas = {
        left: false,
        right: false,
        jump: false
    };

    // Plataformas (x, y, ancho, alto)
    const plataformas = [
        {x: 0, y: HEIGHT - 50, width: 1000, height: 50}, // Plataforma inicial
        {x: 200, y: HEIGHT - 150, width: 150, height: 20},
        {x: 450, y: HEIGHT - 230, width: 150, height: 20},
        {x: 700, y: HEIGHT - 180, width: 100, height: 20},
        {x: 900, y: HEIGHT - 250, width: 200, height: 20},
        {x: 1200, y: HEIGHT - 130, width: 200, height: 20},
        {x: 1500, y: HEIGHT - 210, width: 250, height: 20},
        {x: 1800, y: HEIGHT - 60, width: 300, height: 20},
        {x: 2200, y: HEIGHT - 100, width: 100, height: 20}, // Plataforma para la meta
    ];

    // Monedas (x, y, radio)
    let monedas = [
        {x: 250, y: HEIGHT - 180, radio: 10, recogida: false},
        {x: 500, y: HEIGHT - 260, radio: 10, recogida: false},
        {x: 950, y: HEIGHT - 280, radio: 10, recogida: false},
        {x: 1300, y: HEIGHT - 160, radio: 10, recogida: false},
        {x: 1650, y: HEIGHT - 240, radio: 10, recogida: false},
        {x: 2250, y: HEIGHT - 130, radio: 10, recogida: false}, // Moneda cerca de la meta
    ];

    // Enemigos (x, y, width, height, velocidad)
    let enemigos = [
        {x: 300, y: HEIGHT - 70, width: 40, height: 40, dir: 1, speed: 3, minX: 300, maxX: 500},
        {x: 850, y: HEIGHT - 290, width: 40, height: 40, dir: -1, speed: 2, minX: 850, maxX: 1100},
        {x: 1600, y: HEIGHT - 70, width: 40, height: 40, dir: 1, speed: 3, minX: 1600, maxX: 1800},
        {x: 1900, y: HEIGHT - 70, width: 40, height: 40, dir: -1, speed: 2, minX: 1900, maxX: 2050},
    ];

    // Meta (x, y, ancho, alto)
    const meta = {x: 2200, y: HEIGHT - 110, width: 60, height: 60}; // Ajustado para que esté en la última plataforma

    // Estado juego
    let juegoTerminado = false;
    let mensajeVictoria = '';
    let mensajeDerrota = '';

    // --- Funciones de Dibujo --- //

    function dibujarRect(x, y, w, h, color) {
        ctx.fillStyle = color;
        ctx.fillRect(x, y, w, h);
    }

    function dibujarCirculo(x, y, r, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        ctx.fill();
    }

    // --- Funciones de Lógica de Juego --- //

    function colisionCirculoRect(cx, cy, r, rx, ry, rw, rh) {
        // Encontrar el punto más cercano en el rectángulo al centro del círculo
        let closestX = Math.max(rx, Math.min(cx, rx + rw));
        let closestY = Math.max(ry, Math.min(cy, ry + rh));

        // Calcular la distancia entre el centro del círculo y el punto más cercano
        let distX = cx - closestX;
        let distY = cy - closestY;

        // Si la distancia al cuadrado es menor que el radio al cuadrado, hay colisión
        return (distX * distX + distY * distY) < (r * r);
    }

    // Detección de colisión del jugador con las plataformas
    function detectarColisionPlataformas() {
        jugador.enSuelo = false;

        for (let p of plataformas) {
            // Solo considerar colisiones si el jugador está cayendo o ya está en el suelo
            if (jugador.velY >= 0 &&
                colisionCirculoRect(jugador.x, jugador.y + jugador.radio, jugador.radio, p.x, p.y, p.width, p.height)) {
                
                // Asegurar que el jugador esté exactamente sobre la plataforma
                jugador.y = p.y - jugador.radio;
                jugador.velY = 0; // Detener la caída
                jugador.enSuelo = true; // El jugador está en el suelo
                jugador.saltosRestantes = 2; // Restaurar saltos al tocar el suelo
                break; // Una vez que colisiona con una plataforma, no necesitamos revisar más
            }
        }
    }

    // Mover enemigos y manejar su lógica de movimiento
    function moverEnemigos() {
        for (let e of enemigos) {
            e.x += e.speed * e.dir; // Mover al enemigo
            // Invertir dirección si alcanza los límites
            if (e.x < e.minX) {
                e.x = e.minX;
                e.dir *= -1;
            } else if (e.x + e.width > e.maxX) {
                e.x = e.maxX - e.width;
                e.dir *= -1;
            }
        }
    }

    // Verificar colisiones entre el jugador y los enemigos
    function verificarColisionesEnemigos() {
        for (let e of enemigos) {
            if (colisionCirculoRect(jugador.x, jugador.y, jugador.radio, e.x, e.y, e.width, e.height)) {
                perderVida();
                break; // Solo pierde una vida por colisión múltiple a la vez
            }
        }
    }

    // Verificar colisión con monedas y recogerlas
    function verificarMonedas() {
        for (let m of monedas) {
            if (!m.recogida) {
                let dx = jugador.x - m.x;
                let dy = jugador.y - m.y;
                let dist = Math.sqrt(dx * dx + dy * dy);
                if (dist < jugador.radio + m.radio) {
                    m.recogida = true; // Marcar moneda como recogida
                    jugador.puntos += 10; // Sumar puntos
                    // Podrías añadir un sonido o animación aquí
                }
            }
        }
    }

    // Lógica para cuando el jugador pierde una vida
    function perderVida() {
        jugador.vidas--;
        if (jugador.vidas <= 0) {
            juegoTerminado = true;
            mensajeDerrota = '¡Has perdido! Toca la pantalla para reiniciar.';
        } else {
            // Reiniciar posición del jugador
            jugador.x = 50;
            jugador.y = HEIGHT - 70;
            jugador.velX = 0;
            jugador.velY = 0;
            jugador.saltosRestantes = 2;
        }
    }

    // Verificar si el jugador se ha caído del mapa
    function verificarCaida() {
        if (jugador.y - jugador.radio > HEIGHT + 50) { // Un poco más abajo que el final del canvas
            perderVida();
        }
    }

    // Verificar si el jugador ha llegado a la meta
    function verificarMeta() {
        if (colisionCirculoRect(jugador.x, jugador.y, jugador.radio, meta.x, meta.y, meta.width, meta.height)) {
            juegoTerminado = true;
            mensajeVictoria = '¡Victoria! "Todo lo puedo en Cristo que me fortalece" - Filipenses 4:13';
        }
    }

    // Reiniciar todas las variables del juego a su estado inicial
    function reiniciarJuego() {
        jugador.x = 50;
        jugador.y = HEIGHT - 70;
        jugador.velX = 0;
        jugador.velY = 0;
        jugador.enSuelo = false;
        jugador.saltosRestantes = 2;
        jugador.vidas = 3;
        jugador.puntos = 0;
        monedas.forEach(m => m.recogida = false); // Restablecer todas las monedas
        juegoTerminado = false;
        mensajeVictoria = '';
        mensajeDerrota = '';
    }

    // --- Manejo de Eventos (Teclado y Táctil) --- //

    // Eventos de teclado
    window.addEventListener('keydown', (e) => {
        if (juegoTerminado) {
            if (e.key.toLowerCase() === 'r') reiniciarJuego();
            return;
        }
        if (e.key === 'ArrowLeft') teclas.left = true;
        if (e.key === 'ArrowRight') teclas.right = true;
        if (e.key === 'ArrowUp' || e.key === ' ') {
            if (jugador.saltosRestantes > 0) {
                jugador.velY = SALTO_FUERZA;
                jugador.saltosRestantes--;
            }
        }
    });

    window.addEventListener('keyup', (e) => {
        if (e.key === 'ArrowLeft') teclas.left = false;
        if (e.key === 'ArrowRight') teclas.right = false;
    });

    // Controles táctiles (botones específicos)
    document.getElementById('leftBtn').addEventListener('touchstart', e => { teclas.left = true; e.preventDefault(); });
    document.getElementById('leftBtn').addEventListener('touchend', e => { teclas.left = false; e.preventDefault(); });
    document.getElementById('rightBtn').addEventListener('touchstart', e => { teclas.right = true; e.preventDefault(); });
    document.getElementById('rightBtn').addEventListener('touchend', e => { teclas.right = false; e.preventDefault(); });
    document.getElementById('jumpBtn').addEventListener('touchstart', e => {
        if (jugador.saltosRestantes > 0) {
            jugador.velY = SALTO_FUERZA;
            jugador.saltosRestantes--;
        }
        e.preventDefault(); // Previene el zoom o scroll por defecto
    });

    // **NUEVO: Salto al tocar la pantalla del canvas (fuera de los controles)**
    canvas.addEventListener('touchstart', (e) => {
        if (juegoTerminado) {
            // Si el juego ha terminado, cualquier toque en el canvas lo reinicia
            reiniciarJuego();
            return;
        }

        // Obtener la posición del toque relativa al viewport
        const touchX = e.touches[0].clientX;
        const touchY = e.touches[0].clientY;

        // Obtener las dimensiones y posición de los controles para excluirlos
        const controlsRect = document.getElementById('controls').getBoundingClientRect();

        // Verificar si el toque NO está dentro del área de los controles
        if (!(touchX >= controlsRect.left && touchX <= controlsRect.right &&
              touchY >= controlsRect.top && touchY <= controlsRect.bottom)) {
            // Si el toque no es en los controles, entonces es un salto
            if (jugador.saltosRestantes > 0) {
                jugador.velY = SALTO_FUERZA;
                jugador.saltosRestantes--;
            }
        }
        e.preventDefault(); // Previene el scroll o zoom por defecto del navegador
    }, { passive: false }); // { passive: false } es crucial para permitir preventDefault()


    // --- Bucle Principal del Juego --- //

    // Actualizar el estado del jugador (movimiento, gravedad, etc.)
    function actualizarJugador() {
        // Mover horizontalmente
        if (teclas.left) {
            jugador.velX -= 1;
        } else if (teclas.right) {
            jugador.velX += 1;
        } else {
            jugador.velX *= FRICTION; // Aplicar fricción para desacelerar
            if (Math.abs(jugador.velX) < 0.1) jugador.velX = 0; // Detener si la velocidad es muy baja
        }

        // Limitar la velocidad horizontal
        if (jugador.velX > MAX_VEL_X) jugador.velX = MAX_VEL_X;
        if (jugador.velX < -MAX_VEL_X) jugador.velX = -MAX_VEL_X;

        jugador.x += jugador.velX; // Aplicar velocidad horizontal

        // Aplicar gravedad
        jugador.velY += GRAVEDAD;
        jugador.y += jugador.velY; // Aplicar velocidad vertical

        // Asegurar que el jugador no salga por los lados del nivel si hay limites
        // (Aunque con la cámara esto es menos crítico a menos que quieras paredes físicas)

        detectarColisionPlataformas(); // Manejar colisiones con plataformas
    }

    // Función principal de dibujo
    function dibujar() {
        ctx.clearRect(0, 0, WIDTH, HEIGHT); // Limpiar el canvas

        // Fondo
        ctx.fillStyle = COLOR_FONDO;
        ctx.fillRect(0, 0, WIDTH, HEIGHT);

        // Ajustar la cámara (scroll horizontal) para seguir al jugador
        camaraX = jugador.x - WIDTH / 2 + (jugador.radio / 2); // Centrar al jugador
        // Limitar la cámara para que no se salga del inicio o fin del nivel
        const nivelAncho = plataformas[plataformas.length - 1].x + plataformas[plataformas.length - 1].width;
        if (camaraX < 0) camaraX = 0;
        if (camaraX > nivelAncho - WIDTH) camaraX = nivelAncho - WIDTH;


        // Dibujar Plataformas (offset por la cámara)
        for (let p of plataformas) {
            dibujarRect(p.x - camaraX, p.y, p.width, p.height, COLOR_PLATAFORMA);
        }

        // Dibujar Monedas (offset por la cámara)
        for (let m of monedas) {
            if (!m.recogida) {
                dibujarCirculo(m.x - camaraX, m.y, m.radio, COLOR_MONEDA);
            }
        }

        // Dibujar Enemigos (offset por la cámara)
        for (let e of enemigos) {
            dibujarRect(e.x - camaraX, e.y, e.width, e.height, COLOR_ENEMIGO);
        }

        // Dibujar Meta (offset por la cámara)
        dibujarRect(meta.x - camaraX, meta.y, meta.width, meta.height, COLOR_META);

        // Dibujar Jugador (offset por la cámara)
        dibujarCirculo(jugador.x - camaraX, jugador.y, jugador.radio, COLOR_JUGADOR);

        // HUD: Vidas y puntos (siempre visible, no afectado por la cámara)
        ctx.fillStyle = '#000';
        ctx.font = '24px Arial'; // Un poco más grande para mejor lectura
        ctx.fillText(`Vidas: ${jugador.vidas}`, 20, 30);
        ctx.fillText(`Puntos: ${jugador.puntos}`, 20, 60);

        // Mensajes de juego terminado
        if (juegoTerminado) {
            ctx.fillStyle = '#000';
            ctx.font = '36px Arial'; // Mensaje más grande
            ctx.textAlign = 'center';
            if (mensajeVictoria) {
                ctx.fillStyle = 'green';
                ctx.fillText(mensajeVictoria, WIDTH/2, HEIGHT/2 - 20); // Un poco más arriba
                ctx.font = '24px Arial';
                ctx.fillText('Toca la pantalla para reiniciar.', WIDTH/2, HEIGHT/2 + 20);
            }
            if (mensajeDerrota) {
                ctx.fillStyle = 'red';
                ctx.fillText(mensajeDerrota, WIDTH/2, HEIGHT/2);
            }
            ctx.textAlign = 'start'; // Restablecer alineación
        }
    }

    // Bucle principal del juego
    function loop() {
        if (!juegoTerminado) {
            actualizarJugador();
            moverEnemigos();
            verificarColisionesEnemigos();
            verificarMonedas();
            verificarCaida();
            verificarMeta();
        }

        dibujar(); // Siempre dibujar, incluso si el juego ha terminado

        requestAnimationFrame(loop); // Llamar a la función en el siguiente frame de animación
    }

    loop(); // Iniciar el bucle del juego

})();
</script>

</body>
</html>